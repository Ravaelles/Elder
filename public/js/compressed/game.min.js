// =========================================================
// === GENERIC =============================================
// =========================================================

/**
 * Shows popup message with OK|Cancel buttons. Best to use before deleting objects, on Delete button.
 * @param {type} message
 * @returns {Boolean}
 */
function confirmDelete(message, disallowPleaseWaitOverlay) {
    if (!message) {
        message = "Are you sure you want to delete?";
    }

    if (confirm(message)) {
        if (!disallowPleaseWaitOverlay) {
            showPleaseWait();
        }
        return true;
    }
    else {
        return false;
    }
}

/**
 * Displays overlay with "Please wait" text. Based on bootstrap modal. Contains animated progress bar.
 */
function showPleaseWait() {
    var modalLoading = '<div class="modal" id="pleaseWaitDialog" data-backdrop="static" data-keyboard="false role="dialog">\
        <div class="modal-dialog">\
            <div class="modal-content">\
                <div class="modal-header">\
                    <h4 class="modal-title">Please wait...</h4>\
                </div>\
                <div class="modal-body">\
                    <div class="progress">\
                      <div class="progress-bar progress-bar-success progress-bar-striped active" role="progressbar"\
                      aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" style="width:100%; height: 40px">\
                      </div>\
                    </div>\
                </div>\
            </div>\
        </div>\
    </div>';
    $(document.body).append(modalLoading);
    $("#pleaseWaitDialog").modal("show");
}

/**
 * Hides "Please wait" overlay. See function showPleaseWait().
 */
function hidePleaseWait() {
    $("#pleaseWaitDialog").modal("hide");
}

function scrollToElement(selector, miliseconds) {
    if (!miliseconds) {
        miliseconds = 1500;
    }
    $('html, body').animate({
        scrollTop: $(selector).offset().top
    }, miliseconds);
}

function appendErrorToBody(message) {
    $(document.body).append("<div style='background-color: #a22l color: white;'>" + message + "</div>");
}

function setCookie(cookieName, value, expireSecond) {
    var d = new Date();
    d.setTime(d.getTime() + (expireSecond * 1000));
    var expires = "expires=" + d.toGMTString();
    document.cookie = cookieName + "=" + value + "; " + expires;
}

function getCookie(cookieName) {
    var name = cookieName + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ')
            c = c.substring(1);
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

function rand(min, max) {
    return Math.floor((Math.random() * max) + min);
}

function randArray(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function randElem(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function stringStartsWith(string, prefix) {
    return string.lastIndexOf(prefix, 0) === 0;
}

String.prototype.replaceAt = function (index, character) {
    return this.substr(0, index) + character + this.substr(index + character.length);
}

// =========================================================
// ===== SPECIFIC ==========================================
// =========================================================

function typeSounds() {
    $('input').keyup(function (e) {
        playTypeSound();
    });
    $("label").click(function () {
        playTypeSound();
    });
    $("button").click(function () {
        playTypeSound();
    });
    $(".create-account-button").click(function () {
        playTypeSound();
    });
}

function playTypeSound() {
    soundIndex = Math.floor((Math.random() * 5) + 1);
    $(document.body).append('<audio controls autoplay style="display: none" id="audio"><source src="/sound/terminal/type' + soundIndex + '.mp3" type="audio/mpeg"></audio>');
}

function EngineView(width, height) {

    this.width = -1;
    this.height = -1;

    // =========================================================================

    this.constructor = function (width, height) {
        this.width = width;
        this.height = height;
    };
    this.constructor(width, height);

    // =========================================================================

    this.getType = function () {
        return this.type;
    };

}
function buildStyleStringForImg(image, unit, staticImageMode, imageWrapperSelector, width, height) {
    var styleString = "position: relative; ";

    // =========================================================================
    // Handle static mode (just ui animation) or regular, engine mode
    if (staticImageMode) {
        image.marginLeft = imageWrapperSelector.width() / 2 - width / 2;
        image.marginTop = imageWrapperSelector.height() / 2 - height / 2;

        if (unit._action === SPEAR_EQUIP || unit._action === SPEAR_UNEQUIP) {
            image.marginTop -= 18;
            image.marginLeft -= 17;
        }
    }
    else {
        image.marginLeft = -width / 2;
        image.marginTop = -height;

        // =========================================================================
        // Alter WALK animations
        if (unit.isActionWalk()) {

            // Define horizontal movement factor
            if (unit.isActionWithWeapon(WEAPON_SPEAR)) {
                var walkFactor = 0.25; // Spear
                var diagonalWalkFactor = 0.3;
            }
            else {
                var walkFactor = 0.38; // Walk
                var diagonalWalkFactor = 0.32;
            }

            // Define diagonal movement favtor
            var walkToNorthMarginTopBonus = height / 5;

            if (unit._dir === DIR_E) {
                image.marginLeft += width * walkFactor;
            }
            else if (unit._dir === DIR_W) {
                image.marginLeft += (-width * walkFactor);
            }
            else if (unit._dir === DIR_SE) {
                image.marginLeft += width * diagonalWalkFactor;
                image.marginTop += height * diagonalWalkFactor;
            }
            else if (unit._dir === DIR_SW) {
                image.marginLeft -= width * diagonalWalkFactor;
                image.marginTop += height * diagonalWalkFactor;
            }
            else if (unit._dir === DIR_NW) {
                image.marginLeft += (-width * diagonalWalkFactor);
                image.marginTop += (-height * diagonalWalkFactor + walkToNorthMarginTopBonus);
            }
            else if (unit._dir === DIR_NE) {
                image.marginLeft += width * diagonalWalkFactor;
                image.marginTop += (-height * diagonalWalkFactor + walkToNorthMarginTopBonus);
            }
        }

        // =========================================================================
        // Alter SPEAR
        if (unit._action === SPEAR_EQUIP || unit._action === SPEAR_UNEQUIP) {
            if (unit._dir === DIR_SE) {
                image.marginLeft -= 14;
                image.marginTop += 8;
            }
            else if (unit._dir === DIR_SW) {
                image.marginLeft -= 18.5;
            }
            else if (unit._dir === DIR_NE) {
                image.marginLeft += 18;
                image.marginTop += 3.5;
            }
            else if (unit._dir === DIR_NW) {
                image.marginLeft += 15;
            }
            else if (unit._dir === DIR_E) {
                image.marginLeft -= 5;
                image.marginTop += 12;
            }
            else if (unit._dir === DIR_W) {
                image.marginLeft += 4;
            }
        }
    }

    // =========================================================================
    // Include position factor
    image.marginLeft += unit.positionPX;
    image.marginTop += unit.positionPY;

    // =========================================================================
    // Handle margin
    if (image.marginLeft) {
        styleString += "left:" + image.marginLeft + "px; "
    }
    if (image.marginTop) {
        styleString += "top:" + image.marginTop + "px; "
        styleString += "z-index: " + (image.marginTop + height) + "; "
    }
    //                styleString += "border: 1px solid red !important; ";

    return styleString;
}

// =========================================================================

// Actions
ACTION_IDLE = "aa";
ACTION_WALK = "ab";
ACTION_CLIMB_UP = "ae";
ACTION_PICK_UP = "ak";
ACTION_USE = "al";
ACTION_DODGE = "an";
ACTION_HIT = "ao";
ACTION_HIT2 = "ap";
ACTION_HAND_COMBAT = "aq";
ACTION_KICK = "ar";
ACTION_THROW = "as";
ACTION_RUN = "at";
ACTION_RANDOM_STATIC = "RANDOM_STATIC";
// =========================================================================
// Spear actions
SPEAR_IDLE = "ga";
SPEAR_WALK = "gb";
SPEAR_EQUIP = "gc";
SPEAR_UNEQUIP = "gd";
SPEAR_DODGE = "ge";
SPEAR_THRUST = "gf";
SPEAR_THROW = "gm";
SPEAR_RANDOM = "RANDOM_SPEAR";

// =========================================================================
// Weapons
WEAPON_SPEAR = "SPEAR";
WEAPON_10MM_PISTOL = "10MM";

// =========================================================================
// Direction
DIR_W = "w";
DIR_E = "e";
DIR_NW = "nw";
DIR_NE = "ne";
DIR_SW = "sw";
DIR_SE = "se";
DIR_ALL = [DIR_W, DIR_E, DIR_NW, DIR_NE, DIR_SW, DIR_SE];
function DIR_RANDOM() {
    return randElem(DIR_ALL);
}
function DIR_RANDOM_SOUTH() {
    return randElem([DIR_SW, DIR_SE]);
}
function DIR_RANDOM_NORTH() {
    return randElem([DIR_NW, DIR_NE]);
}

// =========================================================================
// People
WARRIOR_MALE = "warr";
WARRIOR_FEMALE = "prim";
SEX_GIRL = "/img/special/sex-girl.png";
// =========================================================================
// Nature
NATURE_TREE = "nature_tree";
NATURE_GRASS = "nature_grass";
// =========================================================================
// Sex
MALE = "nm";
FEMALE = "nf";

/* global DIR_E, DIR_W, DIR_SW, DIR_NW, DIR_NE, DIR_SE, WEAPON_SPEAR, MALE, ACTION_IDLE, engineView */

var BASE_IMG_DIR = "/img/critter/";
var WALK_ANIMATION_LENGTH = 800;
var WALK_ANIMATION_MODIFIER_WHEN_FIRST = 100;

// =========================================================================

var allUnits = [];

var numOfImages = [];
numOfImages['grass'] = 5;
numOfImages['misc'] = 5;
numOfImages['tree'] = 6;

/**
 * This class represents animated unit/sprite/type to be displayed in the browser.
 * It's possible to change unit and animate it using animate() function. Commands can be chained like:
 * <p>var unit = new Unit(json).create()</p>
 *
 * Unit is identified by:
 * - sex - MALE/FEMALE
 * - dir - direction unit is facing - DIR_E, DIR_W, DIR_SE, DIR_SW, DIR_NE, DIR_NW 0
 * - action - currently executed action - choose one of many constans prefixed ACTION_, SPEAR_ etc
 * - type - Fallout identifier of the type in the gif, use constants lik WARRIOR_MALE, WARRIOR_FEMALE etc
 *
 * @param json json string that will be used to create object
 * @returns Unit
 */
function Unit(json) {

    this._id = null; // Unique identifier for the unit
    this._sex = null; // Sex of this unit, use MALE or FEMALE
    this._action = null; // Curenntly executed action, use ACTION_* and others
    this._dir = null; // Direction unit is facing, use DIR_*
    this._type = null; // Type of this unit e.g. WARRIOR_MALE, WARRIOR_FEMALE

    this.staticImageDisplayMode = false;
    this.marginLeft = 0;
    this.marginTop = 0;

    this.positionPX = 0; // Position X in pixels
    this.positionPY = 0; // Position Y in pixels

    this._lastAnimationEndsAt = 0;
    this._divSelector = null;

    // =========================================================================
    // Constructor

    this.constructor = function (json) {
        var parameters;
        if (typeof json === 'string') {
            parameters = JSON.parse(json);
        } else {
            parameters = json;
        }

        this._id = parameters['id'] ? parameters['id'] : __firstFreeUnitId++;
        this._sex = parameters['sex'] ? ("n" + parameters['sex'].toLowerCase()) : MALE;
        this._action = parameters['action'] ? parameters['action'] : ACTION_IDLE;
        this._dir = parameters['dir'] ? parameters['dir'] : DIR_SE;
        this._type = parameters['type'];

        if (!this._type) {
            console.log("Empty unit type for unit:");
            console.log(this);
            alert("Empty unit type passed for new unit");
        }

        allUnits[this._id] = this;
    };
    this.constructor(json);

    // =========================================================================
    // Display

    this.display = function (staticImageDisplayMode) {
        this.staticImageDisplayMode = staticImageDisplayMode;

        var imgObject = this.createImageElement();
        var imageElement = imgObject['imageElement'];
        var imagePath = imgObject['imagePath'];

        // =========================================================================
        // Create wrapper for the image if needed

        if (!this.staticImageDisplayMode) {
            this.createImageWrapper();
        }

        // =========================================================================

        var imageObject = new Image();
        imageObject.unitId = this._id;
        imageObject.unit = this;
        imageObject.imageIsLoaded = false;

        function reloadImage(unitId, imgSource) {
//            $('#unit-img-' + unitId).attr('src', imgSource);
//            $('#unit-img-' + unitId).attr('src', "/img/empty.jpg");
            $('#unit-img-' + unitId).attr('src', imgSource);
        }

        // Define image onload callback
        imageObject.onload = function (event) {
            var debugString = "<script>$('#unit-img-" + this.unitId + "').css('border', '1px solid rgba(255,0,0,0.2)')</script>";
            +"<script>setTimeout(function() { $('#unit-img-" + this.unitId + "').css('border', 'none'); }, 1000)</script>";
            $("#canvas-debug").html(debugString);
            var imgSource = $('#unit-img-' + this.unitId).attr('src');
//            $('#unit-img-' + this.unitId).attr('src', '');
            reloadImage(this.unitId, imgSource);

            if (this.imageIsLoaded) {
                return;
            } else {

                var unit = this.unit;
                this.imageIsLoaded = true;
                this.src = imagePath;
                var width = this.width;
                var height = this.height;

                var imageWrapperSelector = $("#unit-wrapper-" + this.unitId);

                // Add ready <img src=> element to the div wrapper, thus displaying the animation
                imageWrapperSelector.html(imageElement);

                // Assign current image dimensions to the image element
                var imageSelector = $("#unit-img-" + this.unitId);
                unit._imageSelector = imageSelector;
                imageSelector.attr({"imgwidth": width, "imgheight": height});
                imageSelector.css('z-index', unit.positionPY);

                // =========================================================================
                // Add extra STYLE to wrapping div if needed

                var styleString = buildStyleStringForImg(
                        this, unit, staticImageDisplayMode, imageWrapperSelector, width, height
                        );
                if (styleString) {
                    imageSelector.attr("style", styleString);
                }
            }
        };

        // Assign image url
        imageObject.src = imagePath;

        return this;
    };

    // =========================================================================
    // Animation

    this._queueAnimations = [];

    this.queueAnimation = function (options, delay, animationLength) {
        var startAnimatingUnitAfterTime;
        var lastAnimationEndedAgo = this.timeSinceLastAnimationEndedAgo();
        var canStartAnimationNow = lastAnimationEndedAgo >= -20;

        if (!animationLength) {
            animationLength = WALK_ANIMATION_LENGTH;
//            animationLength = 800;
//            animationLength = 2890;
        }
        if (!delay) {
            delay = 0;
        }

        // =========================================================================
        // Define time when next animation could be potentially executed

        if (canStartAnimationNow) {
            startAnimatingUnitAfterTime = 0;
            this._lastAnimationEndsAt = this.timeNow() + delay + animationLength;
        } else {
            startAnimatingUnitAfterTime = -lastAnimationEndedAgo;
            this._lastAnimationEndsAt += delay + startAnimatingUnitAfterTime + animationLength;
//            this._lastAnimationEndsAt += delay + startAnimatingUnitAfterTime + animationLength;
        }

        // =========================================================================
        // Either run an animation now or queue it

        // Run now
        if (canStartAnimationNow && this._queueAnimations.length === 0) {
            this._runAnimationNow(options, delay, animationLength);
        }

        // Doing something else now, so queue it
        else {
            var animationObject = {
                'options': options,
                'animationLength': animationLength,
                'delay': delay
            };
            this._queueAnimations.push(animationObject);
        }

        return this;
    };

    this._runAnimationNow = function (options, delay, animationLength) {
        var unit = this;

        setTimeout(function () {

            // Run callback before the start of animation
            var callbackAnimationAfterStart = options['callbackAnimationAfterStart'];
            if (callbackAnimationAfterStart) {
                callbackAnimationAfterStart(unit, options);
            }

            unit._animate(options);

            // =========================================================================

            setTimeout(function () {

                // Run callback at the end of animation
                var callbackAnimationEnded = options['callbackAnimationEnded'];
                if (callbackAnimationEnded) {
                    callbackAnimationEnded(unit);
                }

                // Run next animation in enqueued
                unit.runNextQueuedAnimationIfNeeded();

            }, animationLength, unit);
        }, delay);

        return this;
    };

    this.runNextQueuedAnimationIfNeeded = function () {
        var nextAnimation = this._queueAnimations.shift();

        if (nextAnimation !== undefined) {
            var options = nextAnimation['options'];
            var animationLength = nextAnimation['animationLength'];
            var delay = nextAnimation['delay'];
            this._runAnimationNow(options, delay, animationLength);
        }
    };

    this._animate = function (options, afterTime) {
        if (!afterTime) {
            afterTime = 0;
        }
        if (!options) {
            options = [];
        }

        // =========================================================================
        // Animation started callback

        var callbackAnimationBeforeStart = options['callbackAnimationBeforeStart'];
        if (callbackAnimationBeforeStart) {
            callbackAnimationBeforeStart(this);
        }

        // =========================================================================

        var unit = this;
        setTimeout(function () {
            unit.handleOptions(options);
            unit.display(unit.staticImageDisplayMode);
        }, afterTime);

        this._lastAnimationStarted += afterTime;

        return this;
    };

    this.timeSinceLastAnimationEndedAgo = function () {
        return this.timeNow() - this._lastAnimationEndsAt;
    };

    this.timeNow = function () {
        return (new Date()).getTime();
    };

    // =========================================================================
    // Animation generic

    this.animation = function (options, delay, animationLength) {
        if (!options) {
            options = {};
        }
        if (!animationLength) {
            animationLength = 1700;
        }
        if (!delay || delay < 0) {
            delay = 0;
        }

        this.queueAnimation(options, delay, animationLength);

        return this;
    };

    // Walk

    this.walk = function (options, delay) {
//        var walkAnimationTimespan = 990;
        var walkAnimationTimespan = WALK_ANIMATION_LENGTH +
                +(this._queueAnimations.length === 0 ? WALK_ANIMATION_MODIFIER_WHEN_FIRST : 0);
//        console.l  og(this._queueAnimations.length + " / " + walkAnimationTimespan);
//        console.l  og(walkAnimationTimespan);
        var lastAnimationEnded = this.timeSinceLastAnimationEndedAgo();
        var startAnimatingUnitAfterTime;

        if (!delay) {
            delay = 0;
        }
        if (!options) {
            options = [];
        }

        // =========================================================================

        options['callbackAnimationAfterStart'] = function (unit, options) {
            unit.convertActionToWalk();
        };

        options['callbackAnimationEnded'] = function (unit) {
            unit.handleWalkPositionChange();

            if (unit._queueAnimations.length === 0) {
                unit.convertActionToIdle();
                unit._animate();
            }
        };

        this.queueAnimation(options, delay, walkAnimationTimespan);

        return this;
    };

    this.convertActionToWalk = function () {
        this._action = this._action.replaceAt(1, "b");
        return this;
    };

    this.convertActionToIdle = function () {
        this._action = this._action.replaceAt(1, "a");
        return this;
    };

    this.handleWalkPositionChange = function () {
        var fullStep = 82;
        var halfStep = 36;

        var dx = 0;
        var dy = 0;

        if (this._dir === DIR_E) {
            dx += fullStep;
        } else if (this._dir === DIR_W) {
            dx -= fullStep;
        } else if (this._dir === DIR_SE) {
            dx += halfStep;
            dy += halfStep;
        } else if (this._dir === DIR_SW) {
            dx -= halfStep;
            dy += halfStep;
        } else if (this._dir === DIR_NW) {
            dx -= halfStep;
            dy -= halfStep;
        } else if (this._dir === DIR_NE) {
            dx += halfStep;
            dy -= halfStep;
        }

        this.positionPX += dx;
        this.positionPY += dy;

        return this;
    };

    // Equip weapons

    this.equipWeapon = function (weaponName, delay) {
        var options = {action: window[weaponName + "_EQUIP"]};
        options['callbackAnimationEnded'] = function (unit) {
            unit._action = window[weaponName + "_IDLE"];
        };

        if (weaponName === WEAPON_SPEAR) {
            var animationLength = 1300;
        } else {
            var animationLength = 1300;
        }

        this.queueAnimation(options, delay, animationLength);
        return this;
    };

    // =========================================================================
    // Positioning

    this.positionRandomly = function () {
        this.positionPX = rand(0, engineView.width);
        this.positionPY = rand(0, engineView.height);
        return this;
    };

    this.position = function (x, y) {
        if (!x && !y) {
            return {x: this.positionPX, y: this.positionPY};
        } else {
            this.positionPX = x;
            this.positionPY = y;
            return this;
        }
    };

    // =========================================================================
    // HTML creation

    this.createImageElement = function () {
        var id = "unit-img-" + this._id;
        var idString = this._id ? "id='" + id + "'" : "";
        var imgClass = "";

        // Animated image
        if (!this.isStaticImage()) {
            var imgName = BASE_IMG_DIR + "all/" + this._sex + this._type + this._action + "_" + this._dir;
//            var imgName = "/image/critter/all/" + this._sex + this._type + this._action + "_" + this._dir;
//            var randomString = "?" + rand(100000, 999999);
//            var randomString = "?" + this._id + "-" + rand(0, 99999);
//            var randomString = "?" + this._id;
//            var imagePath = imgName + ".gif" + randomString;
//            var imagePath = imgName + ".gif?" + this._id;
            var imagePath = imgName + ".gif";
            imgClass = "unit-alive";
//            specialAttributes = "loop=infinite";
        }

        // Static image
        else {
            var natureGroupName = this._type.substring(7);
            var imgName = "/img/nature/" + natureGroupName + "/" + rand(1, numOfImages[natureGroupName]);
            var imagePath = imgName + ".png";
        }

        // =========================================================================
        // Direction issues
//        if (!this.isActionStatic()) {
//            if (this.dirTowardEast()) {
//                this.marginLeft = 0;
//            }
//            else if (this.dirTowardWest()) {
//                this.marginLeft = 0;
//            }
//        }
//        this.marginTop = 60 + $("#" + id).height() * -1;
//        this.marginTop = 15;
//        if (this.dirTowardNorth()) {
        //        }

        // =========================================================================
        // Response contains various elements that can be needed, include them all

//        var styleString = "border: 1px solid red !important";
        var imageElement = "<img " + idString + " class='" + imgClass + "' src='" + imagePath + "' />";
        return {"imageElement": imageElement, "imagePath": imagePath};
    };

    // =========================================================================
    // Low-level methods

    this.createImageWrapper = function () {
        var unitIdString = "unit-wrapper-" + this._id;

        if (this._divSelector !== null) {
            this._divSelector.html("<div class='engine-unit' id='" + unitIdString + "'></div>");
        } else {
            $("#canvas").append("<div class='engine-unit' id='" + unitIdString + "'></div>");
            this._divSelector = $("#canvas #" + unitIdString);
        }
    };

    this.handleOptions = function (options) {
        if (options) {
            if (typeof options.action !== 'undefined') {
                this._action = options.action;
            }
            if (typeof options.sex !== 'undefined') {
                this._sex = options.sex;
            }
            if (typeof options.dir !== 'undefined') {
                this._dir = options.dir;
            }
            if (typeof options.type !== 'undefined') {
                this._type = options.type;
            }
        }
        return this;
    };

    this.dirTowardEast = function () {
        return [DIR_E, DIR_SE, DIR_NE].indexOf(this._dir) !== -1;
    };

    this.dirTowardWest = function () {
        return [DIR_W, DIR_NW, DIR_SW].indexOf(this._dir) !== -1;
    };

    this.dirTowardNorth = function () {
        return [DIR_NW, DIR_NE].indexOf(this._dir) !== -1;
    };

    this.dirTowardSouth = function () {
        return [DIR_SW, DIR_SE].indexOf(this._dir) !== -1;
    };

//    this.isActionStatic = function () {
//        return [ACTION_IDLE, SPEAR_IDLE].indexOf(this._dir) != -1;
//        return false;
    //    };

    this.isStaticImage = function () {
        return this._type !== null && stringStartsWith(this._type, "nature_");
    };

    this.isActionWalk = function () {
        return this._action.charAt(1) === "b";
    };

    this.isActionWithWeapon = function (weaponName) {
        if (weaponName === WEAPON_SPEAR) {
            weaponLetter = "g";
        } else {
            weaponLetter = "a"; // Generic actions
        }
        return this._action.charAt(0) === weaponLetter.charAt(0);
    };

    // =========================================================================
    // Getters and Setters

    /**
     * Getter or Setter for <b>dir</b> field.
     * @param newDir one of DIR_* variables
     */
    this.dir = function (newDir) {
        if (newDir !== undefined) {
            this._dir = newDir;
        } else {
            return this._dir;
        }
    };

    /**
     * Getter or Setter for <b>action</b> field.
     * @param newAction one of ACTION_* variables or others like that
     */
    this.action = function (newAction) {
        if (newAction !== undefined) {
            this._action = newAction;
        } else {
            return this._action;
        }
    };

}

// =========================================================================

__firstFreeUnitId = 100;

function isDefined(param) {
    return typeof param != 'undefined';
}

function isUndefined(param) {
    return typeof param == 'undefined';
}

function cloneObject(object) {
    return JSON.parse(JSON.stringify(object));
}
function getMapCoordinatesFromScreenClick(event) {

    // Define click on map canvas manually, because if clicked on a child, it changes .offsetX value.
    var canvasX = event.pageX - WORLDMAP_CANVAS_MARGIN_LEFT;
    var canvasY = event.pageY - WORLDMAP_CANVAS_MARGIN_TOP;

    return getMapCoordinatesFromCanvasCoordinates(canvasX, canvasY);
}

function getMapCoordinatesFromCanvasCoordinates(canvasX, canvasY) {

    // X-related
    var coordinatesOffsetX = getMapOffsetPixelsX() * getWorldmapZoom();
    var mapScreenWidth = WORLDMAP_CANVAS_WIDTH * getWorldmapZoom();
    var mapScreenWidthPercent = canvasX / WORLDMAP_CANVAS_WIDTH;

    // Y-related
    var coordinatesOffsetY = getMapOffsetPixelsY() * getWorldmapZoom();
    var mapScreenHeight = WORLDMAP_CANVAS_HEIGHT * getWorldmapZoom();
    var mapScreenHeightPercent = canvasY / WORLDMAP_CANVAS_HEIGHT;

    // Return object
    var mapX = parseInt(coordinatesOffsetX + mapScreenWidthPercent * mapScreenWidth);
    var mapY = parseInt(coordinatesOffsetY + mapScreenHeightPercent * mapScreenHeight);
    return {'mapX': mapX, 'mapY': mapY};
}

function getCanvasCoordinatesFromMapCoordinates(mapX, mapY) {
    return {
        'canvasX': WORLDMAP_CANVAS_MARGIN_LEFT + mapX / getWorldmapZoom() - getMapOffsetPixelsX() + 2,
        'canvasY': WORLDMAP_CANVAS_MARGIN_TOP + mapY / getWorldmapZoom() - getMapOffsetPixelsY() + 1
    };
}

// =========================================================================

function getCurrentTopLeftPointMapCoordinates() {
    return getMapCoordinatesFromCanvasCoordinates(0, 0);
}

// =========================================================================

function coordinatesToString(coordinates) {
    if ('canvasX' in coordinates) {
        return "[" + coordinates['canvasX'] + "," + coordinates['canvasY'] + "]";
    } else {
        return "[" + coordinates['mapX'] + "," + coordinates['mapY'] + "]";
    }
}
function HtmlElement(left, top) {

    this._id = null; // Unique identifier
    this._selector = null; // jQuery selector of this html element
    this._top = null; // CSS "top" value in pixels
    this._left = null; // CSS "left" value in pixels
    this._htmlDOM = null; // DOM element that was used to create this html element
    this._styleString = null; // All styles for this element except "top" and "left"
    this._htmlString = null; // Ready html string

    // =========================================================================
    // Constructor

    this.constructor = function (left, top) {
        this._id = __firstFreeWorldmapElementId++;
        this._htmlDOM = document.createElement("div");
        this._left = left;
        this._top = top;

//        for (var fieldName in options) {
//            var value = options[fieldName];
//            fieldName = "_" + fieldName;
//            this.fieldName = value;
//        }
    };
    this.constructor(left, top);

    // =========================================================================

    this.getId = function () {
        return this._id;
    };

    this.getSelector = function () {
        if (this._selector === null) {
            this._selector = $("#html-element-" + this._id)
        }
        return this._selector;
    };

    // === Style ======================================================================

    this.setStyle = function (styleString) {
        this._styleString = styleString;
        this._htmlDOM.setAttribute('id', 'html-element-' + this._id);
        this._htmlDOM.setAttribute('style', styleString);
    };

    // === HTML elements ======================================================================

    this.getHtml = function () {
        if (this._htmlString === null) {
            this.prepareHtml();
        }
        return this._htmlString;
    };

    this.prepareHtml = function () {
        this.updateHtmlDOMPosition();
        this._htmlString = this._htmlDOM.outerHTML;
    };

    this.updateHtmlDOMPosition = function () {
        var style = this._styleString;
        style += "top:" + this._top + "px;";
        style += "left:" + this._left + "px;";
        this._htmlDOM.setAttribute('style', style);
    };

    // === Position ======================================================================

    this.translate = function (dx, dy) {
        this._left += dx;
        this._top += dy;

        this.getSelector().css({
            'left': this._left + 'px',
            'top': this._top + 'px'
        });
    };

//    this.setTop = function (top) {
//        this._top = top;
//    };

//    this.getTop = function () {
//        return this._top;
//    };

//    this.setLeft = function (left) {
//        this._left = left;
//    };

//    this.getLeft = function () {
//        return this._left;
//    };

}

// =========================================================================

__firstFreeWorldmapElementId = 1;


var FORBID_RIGHT_CLICK = false;

// =========================================================================

var mouseIsClicked = false;
var mousePreviousPosition = null;
var mouseHasMoved = false;

// === Map events ======================================================================

function initializeWorldmapEvents() {
    $(".worldmap-location")
            .mousedown(function (event) {
                mapMouseDown(event);
                event.stopPropagation();
            })
            .mouseup(function (event) {
                mapMouseUp(event);
                event.stopPropagation();
            })
            .mousemove(function (event) {
                mapMouseMove(event);
                event.stopPropagation();
            });

    $(".worldmap")
            .mousedown(function (event) {
                mapMouseDown(event);
            })
            .mouseup(function (event) {
                mapMouseUp(event);
            })
            .mousemove(function (event) {
                mapMouseMove(event);
            })
            .mousewheel(function (event) {
                mapScroll(event);
            })
            .mouseleave(function (event) {
                mapMouseLeave(event);
            })
            .contextmenu(function (event) {
                if (FORBID_RIGHT_CLICK) {
                    event.preventDefault(); // Stop the context menu
                }
            });
}

// =========================================================================

function mapMouseDown(event) {
    worldmap = $(".worldmap");

    // Right click
    if (event.button === 2) {
//        console.log("Right click");
//        event.preventDefault();
//        event.stopPropagation()();
//        return true;
    }

    // Left or middle click
    else {
//        worldmapMessage("Maximum zoom reached!", "#f35");
    }

    mousePreviousPosition = event;
    mouseIsClicked = true;
    mouseHasMoved = false;
}

function mapMouseUp(event) {
    if (!mouseHasMoved) {
        mapClick(event);
    }

    mouseIsClicked = false;
    mousePreviousPosition = null;
    mouseHasMoved = false;
}

function mapMouseMove(event) {
    if (mouseIsClicked) {
        mouseHasMoved = true;
    }

    if (mouseIsClicked && mousePreviousPosition != null) {
        translationVector = moveWorldmapBackgroundImage(event);
        moveWorldmapObjects(translationVector);
    }

    mousePreviousPosition = event;

    // =========================================================================
    // Show coords
    worldmapMessageForever(
            "Mouse points to " + coordinatesToString(getMapCoordinatesFromScreenClick(event)), 'mouse-cords'
            );
}

function mapScroll(event) {
    var scrollType = event.deltaY; // 1 for wheel up, -1 for wheel down

    // Wheel up
    if (scrollType >= 1) {
        changeZoom(event, false);
    }

    // Wheel down
    else if (scrollType <= -1) {
        changeZoom(event, true);
    }

    // Force mouse move event as scroll will change cursor relative position on the map
    mapMouseMove(event);
}

function mapMouseLeave(event) {
    if (mouseIsClicked) {
        mapMouseUp(event);
        mouseIsClicked = false;
    }
}

function mapClick(event) {
    var coordinates = getMapCoordinatesFromScreenClick(event);
    gameLog('<span>[' + coordinates['mapX'] + ',' + coordinates['mapY'] + ']</span> is unknown wasteland, '
            + 'not very hospitable place.');
}
var WORLDMAP_LOCATION_SIZE = null;
var WORLDMAP_LOCATION_LABEL_MARGIN_LEFT = null;
var WORLDMAP_LOCATION_LABEL_MARGIN_TOP = null;

var _WORLDMAP_LOCATION_SIZE_MODIFIER = 35;
var _WORLDMAP_LOCATION_LABEL_WIDTH = 100;

// =========================================================================

function initializeWorldmapLocations() {
    recalculateWorldmapLocationVariables();

    worldmapLocations.forEach(function (location, index) {
        getWorldmap().append(createHtmlFromLocationJson(location, index));
    });
}

// =========================================================================

function createHtmlFromLocationJson(location, index) {
    var id = location['_id'];
//    var text = location['location']['x'] + "," + location['location']['y'];
    var text = location['name'];
    var labelWidth = WORLDMAP_LOCATION_SIZE;

    var canvasCoordinates = getCanvasCoordinatesFromMapCoordinates(
//            location['location']['x'] - size / 2, location['location']['y'] - size / 2
            location['location']['x'], location['location']['y']
            );

    var locationStyle = 'top:' + (canvasCoordinates['canvasY'] - WORLDMAP_LOCATION_SIZE / 2) + 'px;left:'
            + (canvasCoordinates['canvasX'] - WORLDMAP_LOCATION_SIZE / 2) + 'px;'
            + 'width:' + WORLDMAP_LOCATION_SIZE + 'px;height:' + WORLDMAP_LOCATION_SIZE + 'px';

    var labelStyle = 'margin-top:' + WORLDMAP_LOCATION_LABEL_MARGIN_TOP
            + 'px;margin-left:' + WORLDMAP_LOCATION_LABEL_MARGIN_LEFT + 'px';

    return '<div class="worldmap-location" id="worldmap-location-' + id + '" '
            + 'variableName="worldmapLocations" variableIndex="' + index + '" style="' + locationStyle + '">'
            + '<label style="' + labelStyle + '">' + text + '</label>'
            + '</div>';
}

function recalculateWorldmapLocationVariables() {
    WORLDMAP_LOCATION_SIZE = _WORLDMAP_LOCATION_SIZE_MODIFIER / getWorldmapZoom();
    WORLDMAP_LOCATION_BORDER_WIDTH = 1.5;
    WORLDMAP_LOCATION_LABEL_MARGIN_TOP = _WORLDMAP_LOCATION_SIZE_MODIFIER / getWorldmapZoom() * 1.02;
    WORLDMAP_LOCATION_LABEL_MARGIN_LEFT = -_WORLDMAP_LOCATION_LABEL_WIDTH / 2 + WORLDMAP_LOCATION_SIZE / 2
            - WORLDMAP_LOCATION_BORDER_WIDTH + 1;
}
var _WORLDMAP_MESSAGE_SHOW_TIME = 2000;
var _WORLDMAP_MESSAGE_DIM_INTERVAL = 100;

var _worldmapMessageFirstFreeId = 10000;

// =========================================================================

function gameLog(message) {
    $(".game-log p").css('opacity', '0.7');

    $(".game-log").prepend("<p style='display: none' class='game-log-invisible'><span class='dot'>•</span> "
            + message + "</p>");

    $(".game-log .game-log-invisible").slideDown(700);
}

function worldmapMessageForever(text, uniqueForeverMessageId, color) {
    if (typeof uniqueForeverMessageId == 'undefined') {
        console.error("Did not pass worldmapMessageForever unique id!");
        return;
    }
    return worldmapMessage(text, color, uniqueForeverMessageId);
}

function worldmapMessage(text, color, uniqueForeverMessageId) {
    if (color) {
        color = "color: " + color;
    }

    // Define message id
    var messageId = 'game-message-' + (isDefined(uniqueForeverMessageId) ?
            uniqueForeverMessageId : _worldmapMessageFirstFreeId++);

    // =========================================================================
    // Remove previous message if needed

    if (uniqueForeverMessageId) {
        var message = $("#" + messageId);
        if (message.length > 0) {
            message.text(text);
            return;
        }
    }

    // =========================================================================
    // Add html element of message
    $(".game-messages").append("<div class='game-message' id='" + messageId + "' style='width: "
            + WORLDMAP_CANVAS_WIDTH + "px;" + color + ";opacity:1.0'>" + text + "</div>");

    // =========================================================================
    // Decrease message's opacity with time
    if (!uniqueForeverMessageId) {
        setTimeout(function () {
            _dimMessageWithTime(messageId);
        }, _WORLDMAP_MESSAGE_SHOW_TIME);
    }
}

// =========================================================================

function _dimMessageWithTime(messageId) {
    var message = $("#" + messageId);
    var opacity = message.css('opacity');
    if (opacity <= 0) {
        var hideTime = 400;
        message.hide(hideTime);
        setTimeout(function () {
            message.remove();
        }, hideTime);
    } else {
        message.css('opacity', message.css('opacity') - 0.03);
        setTimeout(function () {
            _dimMessageWithTime(messageId);
        }, _WORLDMAP_MESSAGE_DIM_INTERVAL + opacity * 100);
    }
}
var MOUSE_DRAG_MODIFIER = 1;

// === Move map / objects ==============================================================

function moveWorldmapBackgroundImage(eventOrX, yOrNull) {
    if (isUndefined(yOrNull)) {
        var dx = eventOrX.pageX - mousePreviousPosition.pageX;
        var dy = eventOrX.pageY - mousePreviousPosition.pageY;
    } else {
        var dx = eventOrX;
        var dy = yOrNull;
    }

    // =========================================================================
    // Get current image position
    var imagePosX = -1 * getMapOffsetPixelsX();
    var imagePosY = -1 * getMapOffsetPixelsY();

    // Modify variable image position
    deltaImagePosX = dx;
    deltaImagePosY = dy;
    imagePosX += deltaImagePosX;
    imagePosY += deltaImagePosY;
    imagePosXWithScreenWidth = imagePosX - WORLDMAP_CANVAS_WIDTH;
    imagePosYWithScreenHeight = imagePosY - WORLDMAP_CANVAS_HEIGHT;

    // Force image to be horizontally in bounds
    if (imagePosX > 0) {
        var oldImagePosX = imagePosX;
        imagePosX = 0;
        deltaImagePosX -= (oldImagePosX - imagePosX);
    } else if (imagePosXWithScreenWidth <= -WORLDMAP_WIDTH / getWorldmapZoom()) {
        var oldImagePosX = imagePosX;
        imagePosX = -WORLDMAP_WIDTH / getWorldmapZoom() + WORLDMAP_CANVAS_WIDTH;
        deltaImagePosX -= (oldImagePosX - imagePosX);
    }

    // Force image to be vertically in bounds
    if (imagePosY > 0) {
        var oldImagePosY = imagePosY;
        imagePosY = 0;
        deltaImagePosY -= (oldImagePosY - imagePosY);
    } else if (imagePosYWithScreenHeight <= -WORLDMAP_HEIGHT / getWorldmapZoom()) {
        var oldImagePosY = imagePosY;
        imagePosY = -WORLDMAP_HEIGHT / getWorldmapZoom() + WORLDMAP_CANVAS_HEIGHT;
        deltaImagePosY -= (oldImagePosY - imagePosY);
    }

    // Remember current view position
    updateViewRectangle(-1 * imagePosX, -1 * imagePosY);

    // =========================================================================

    return {dx: deltaImagePosX, dy: deltaImagePosY};
}

function moveWorldmapObjects(translationVector) {
    var allWorldmapObjects = getAllWorldmapObjects();
//    console.log("==== WORLDMAP OBJECTS =====");
    for (var key in allWorldmapObjects) {
        var worldmapObject = allWorldmapObjects[key];
//        console.log(worldmapObject);
    }

    // =========================================================================
    // Locations

    var mapLocations = $(".worldmap-location");
    $.each(mapLocations, function (index, object) {
        var mapObject = $("#" + object['id']);
        mapObject.css({
            'top': parseFloat(mapObject.css('top')) + translationVector['dy'],
            'left': parseFloat(mapObject.css('left')) + translationVector['dx']
        });
    });

    // =========================================================================
    // Worldmap objects

    $.each(_allWorldmapObjects, function (index, worldmapObject) {
        worldmapObject.translate(translationVector['dx'], translationVector['dy']);
    });
}
function WorldmapObject(options) {

    this._id = null; // Unique identifier for the worldmap object
    this._x = null; //
    this._y = null; //
    this._x2 = null; //
    this._y2 = null; //
    this._htmlElements = []; //

    // =========================================================================
    // Constructor

    this.constructor = function (options) {
        this._id = __firstFreeWorldmapObjectId++;

        for (var fieldName in options) {
            var value = options[fieldName];
            fieldName = "_" + fieldName;
            this.fieldName = value;
        }
    };
    this.constructor(options);

    this.getId = function () {
        return this._id;
    };

    // === HTML elements ======================================================================

    this.addHtmlElement = function (htmlElement) {
        var htmlElementId = htmlElement.getId();
        this._htmlElements[htmlElementId] = htmlElement;
        return this;
    };

    this.getHtmlElements = function () {
        return this._htmlElements.slice();
    };

    // === Coordinates ======================================================================

    this.setCoordinates = function (x, y) {
        this._x = x;
        this._y = y;
        return this;
    };

    this.setEndCoordinates = function (x2, y2) {
        this._x2 = x2;
        this._y2 = y2;
        return this;
    };

    this.getCoordinates = function () {
        return {'x': this._x, 'y': this._y};
    };

    this.translate = function (dx, dy) {
        this._x += dx;
        this._y += dy;

        for (var htmlElementId in this._htmlElements) {
            var htmlElementObject = this._htmlElements[htmlElementId];
            htmlElementObject.translate(dx, dy);
        }
    };

}

// =========================================================================

__firstFreeWorldmapObjectId = 1;
var _allWorldmapObjects = {};

// =========================================================================

function getAllWorldmapObjects() {
    return _allWorldmapObjects;
}

function addWorldmapObject(worldmapObject) {

    // For every html element, add it to the worldmap canvas
    var htmlElements = worldmapObject.getHtmlElements();
    for (var index in htmlElements) {
        var htmlElement = htmlElements[index];
        getWorldmap().append(htmlElement.getHtml());
    }

    // Add object to the list
    _allWorldmapObjects[worldmapObject.getId()] = worldmapObject;
}


WENGINE_DEFAULT_LINE_WIDTH = 1;

// =========================================================================

window.initQueue.push(function () {
    setTimeout(function () {
        var rect = getWorldmapViewRectangle();
        var TEMP = 30;

        rect['x'] += TEMP;
        rect['y'] += TEMP;
        rect['width'] -= 2 * TEMP + WENGINE_DEFAULT_LINE_WIDTH;
        rect['height'] -= 2 * TEMP + WENGINE_DEFAULT_LINE_WIDTH;
        rect['width'] /= getWorldmapZoom();
        rect['height'] /= getWorldmapZoom();

//        WEngine_paintRectangleFromArray(rect, {'background-color': 'transparent'});
        paintTest();
    }, 160);
});

// =========================================================================

var testLineX1;
var testLineY1;
var testLineX2;
var testLineY2;
function paintTest() {
    testLineX1 = _WORLDMAP_IMAGE_INITIAL_X + 300;
    testLineY1 = _WORLDMAP_IMAGE_INITIAL_Y + 400;
    testLineX2 = testLineX1;
    testLineY2 = testLineY1;

    var line = WEngine_paintLine(testLineX1, testLineY1, testLineX2, testLineY2);
    console.log(line);

    setTimeout(function () {
        testLineX2
    }, 100);
}

// === Public ======================================================================

function WEngine_paintLine(x1, y1, x2, y2, options, worldmapObject) {
    //    console.log("Line: " + x1 + "," + y1 + " / " + x2 + "," + y2);
    canvasCoords = getCanvasCoordinatesFromMapCoordinates(x1, y1);
    x1 = canvasCoords['canvasX'];
    y1 = canvasCoords['canvasY'];
    canvasCoords = getCanvasCoordinatesFromMapCoordinates(x2, y2);
    x2 = canvasCoords['canvasX'];
    y2 = canvasCoords['canvasY'];

    var line = _WEngine_getLine(x1, y1, x2, y2, options);

    // =========================================================================
    // Worldmap object related - automatically create only if no worldmapObject was passed
    if (isUndefined(worldmapObject)) {
        worldmapObject = new WorldmapObject();
        worldmapObject.setCoordinates(x1, y1);
        worldmapObject.setEndCoordinates(x2, y2);
        worldmapObject.addHtmlElement(line);
        addWorldmapObject(worldmapObject);

        // Return WORLDMAP OBJECT
        return worldmapObject;
    }

    // If passed existing WorldmapObject return HTML ELEMENT
    else {
        return line;
    }
}

function WEngine_paintRectangleFromArray(array, options) {
    return WEngine_paintRectangle(
            array['x'], array['y'], array['x'] + array['width'], array['y'] + array['height'], options
            );
}

function WEngine_paintRectangle(x1, y1, x2, y2, options) {
    var worldmapObject = new WorldmapObject();
    worldmapObject.setCoordinates(x1, y1);
    worldmapObject.setEndCoordinates(x2, y2);

    worldmapObject.addHtmlElement(WEngine_paintLine(x1, y1, x2, y1, options, worldmapObject)); // Horiz Top
    worldmapObject.addHtmlElement(WEngine_paintLine(x1, y2, x2, y2, options, worldmapObject)); // Horiz Bottom
    worldmapObject.addHtmlElement(WEngine_paintLine(x1, y1, x1, y2, options, worldmapObject)); // Vert Left
    worldmapObject.addHtmlElement(WEngine_paintLine(x2, y1, x2, y2, options, worldmapObject)); // Vert Right

    addWorldmapObject(worldmapObject);
    return worldmapObject;
}

// === Private ======================================================================

function _WEngine_getLine(x1, y1, x2, y2, options) {
    var a = x1 - x2,
            b = y1 - y2,
            c = Math.sqrt(a * a + b * b);

    var sx = (x1 + x2) / 2,
            sy = (y1 + y2) / 2;

    var x = sx - c / 2,
            y = sy;

    var alpha = Math.PI - Math.atan2(-b, a);

    return _WEngine_getLine_element(x, y, c, alpha, options);
}

// === Html elements ======================================================================

//function _WEngine_getLine_element(x, y, length, angle, options) {
//    var line = document.createElement("div");
//    var styles = 'border: ' + WENGINE_DEFAULT_LINE_WIDTH + 'px dashed red; '
//            + 'width: ' + length + 'px; '
//            + 'height: 0px; '
//            + '-moz-transform: rotate(' + angle + 'rad); '
//            + '-webkit-transform: rotate(' + angle + 'rad); '
//            + '-o-transform: rotate(' + angle + 'rad); '
//            + '-ms-transform: rotate(' + angle + 'rad); '
//            + 'position: absolute; '
//            + 'top: ' + y + 'px; '
//            + 'left: ' + x + 'px; ';
//
//    if (isDefined(options)) {
//        for (var option in options) {
//            styles += option + ':' + options[option] + ';';
//        }
//    }
//
//    line.setAttribute('style', styles);
//    _WEngine_assignIdToHtmlElement(line);
//    return line;
//}
function _WEngine_getLine_element(x, y, length, angle, options) {
    var lineHtmlElement = new HtmlElement(x, y);
    var style = 'border: ' + WENGINE_DEFAULT_LINE_WIDTH + 'px dashed red; '
            + 'width: ' + length + 'px; '
            + 'height: 0px; '
            + '-moz-transform: rotate(' + angle + 'rad); '
            + '-webkit-transform: rotate(' + angle + 'rad); '
            + '-o-transform: rotate(' + angle + 'rad); '
            + '-ms-transform: rotate(' + angle + 'rad); '
            + 'position: absolute; ';
//            + 'top: ' + y + 'px; '
//            + 'left: ' + x + 'px; ';;

    if (isDefined(options)) {
        for (var option in options) {
            style += option + ':' + options[option] + ';';
        }
    }

    lineHtmlElement.setStyle(style);
    return lineHtmlElement;
}

// =========================================================================

//function _WEngine_assignIdToHtmlElement(element) {
//    __lastHtmlElementId = (__firstFreeWorldmapObjectHtmlElementId++);
//    element.setAttribute('id', 'html-element-' + __lastHtmlElementId);
//    return __lastHtmlElementId;
//}

__firstFreeWorldmapObjectHtmlElementId = 100;
//__lastHtmlElementId = null;

// Initial view settings
var _WORLDMAP_IMAGE_INITIAL_WIDTH = 3500;
var _WORLDMAP_IMAGE_INITIAL_X = 1000;
var _WORLDMAP_IMAGE_INITIAL_Y = 1000;

// View rectangle
var _worldmapViewRectangle = null;
var _currentWorldmapImageWidth = null;
var _currentWorldmapImageHeight = null;

// === Set up view & zoom ===================================================

function initializeWorldmapView() {

    // Define rectangle view width and height
    _currentWorldmapImageWidth = _WORLDMAP_IMAGE_INITIAL_WIDTH;
    _currentWorldmapImageHeight = _currentWorldmapImageWidth * WORLDMAP_CANVAS_WIDTH / WORLDMAP_CANVAS_HEIGHT;

    // Definte rectangle view
    _worldmapViewRectangle = {
        'x': _WORLDMAP_IMAGE_INITIAL_X,
        'y': _WORLDMAP_IMAGE_INITIAL_Y,
        'width': WORLDMAP_CANVAS_WIDTH,
        'height': WORLDMAP_CANVAS_HEIGHT
    };

    // Init zoom
    initializeWorldmapZoom();

    // Assign proper values for background image
    updateViewRectangle(_worldmapViewRectangle['x'], _worldmapViewRectangle['y']);
}

// === Public ======================================================================

function getWorldmapViewRectangle() {
    return cloneObject(_worldmapViewRectangle);
}

function getWorldmapViewRectangleWidth() {
    return _worldmapViewRectangle['width'];
}

function getWorldmapViewRectangleHeight() {
    return _worldmapViewRectangle['height'];
}

function getMapOffsetPixelsX() {
    return _worldmapViewRectangle['x'];
}

function getMapOffsetPixelsY() {
    return _worldmapViewRectangle['y'];
}

function updateViewRectangle(xOrObject, yOrObject) {

    // If params are defined, it means we need to move by view rectangle [x,y]
    if (isDefined(xOrObject)) {
        var newX, newY;
        if (xOrObject != null) {
            newX = Math.abs(xOrObject);
            newY = Math.abs(yOrObject);
        } else {
            newX = Math.abs(xOrObject['x']);
            newY = Math.abs(yOrObject['y']);
        }

        _worldmapViewRectangle['x'] = newX;
        _worldmapViewRectangle['y'] = newY;

        // Update background image position
        getWorldmap().css({
            'background-position': -newX + "px " + -newY + "px"
        });
    }

    // Update width and height of view rectangle
    _worldmapViewRectangle['width'] = WORLDMAP_CANVAS_WIDTH / getWorldmapZoom();
    _worldmapViewRectangle['height'] = WORLDMAP_CANVAS_HEIGHT / getWorldmapZoom();

    // Update background image size
    getWorldmap().css({
        'background-size': _currentWorldmapImageWidth + "px auto"
    });

    // =========================================================================
    // Return difference in view rectangle field values

//    console.log('');
//    console.log("NEW:");
//    console.log(_worldmapViewRectangle);
//    console.log("OLD");
//    console.log(_oldWorldmapViewRectangle);

//    return {
//        'dX': (_worldmapViewRectangle['x'] - _oldWorldmapViewRectangle['x']),
//        'dY': (_worldmapViewRectangle['y'] - _oldWorldmapViewRectangle['y']),
//        'dWidth': (_worldmapViewRectangle['width'] - _oldWorldmapViewRectangle['width']),
//        'dHeight': (_worldmapViewRectangle['height'] - _oldWorldmapViewRectangle['height'])
//    };
}

// Zoom animation
var _WORLDMAP_ZOOM_INTERVAL = 15; // Miliseconds of interval between zoom animations
var _WORLDMAP_ZOOM_ANIMATIONS = 25; // Number of zoom animations
//var _WORLDMAP_ZOOM_SPEED_FACTOR = 3; //
var _worldmapZoomsToProceedCounter = 0; // How many zoom animation are left to proceed
//var _worldmapZoomCurrentSpeed = 0; //

// Zoom
var _MIN_ZOOM_VALUE = 0.58; // Do not lower - below this value some weird floating things happen
var _zoomStep = 50; // Background image width quantum pixel difference
var _zoom; // Current zoom - actually lower value is bigger zoom
var _zoomMessageWasShown = false;

// Revert zoom
var _oldMapImageWidth = null;
var _oldZoom = null;
var _oldWorldmapViewRectangle = {'x': 0, 'y': 0, 'width': 0, 'height': 0};

// =========================================================================

function initializeWorldmapZoom() {
    _recalculateZoom();
}

// === Public ======================================================================

function getWorldmapZoom() {
    return _zoom;
}

function changeZoom(event, isZoomIn) {
    _zoomMessageWasShown = false;

    _worldmapZoomsToProceedCounter = _WORLDMAP_ZOOM_ANIMATIONS;
    _delayChangeZoom(event, isZoomIn);
}

// === Zoom related ==============================================================

function _delayChangeZoom(event, isZoomIn) {
    setTimeout(function () {
        _processZoom(event, isZoomIn);
    }, _WORLDMAP_ZOOM_INTERVAL);
}

function _processZoom(event, isZoomIn) {

    // Validate that we need to zoom smoothly
    if (_worldmapZoomsToProceedCounter > 0) {
        _worldmapZoomsToProceedCounter--;
//        _worldmapZoomCurrentSpeed += Math.sqrt(_WORLDMAP_ZOOM_SPEED_FACTOR);
    } else {
//        _worldmapZoomCurrentSpeed = 0;
        return;
    }

    // =========================================================================
    // Remember initial view variables
    _oldMapImageWidth = _currentWorldmapImageWidth;
    _oldZoom = _zoom;
    _oldWorldmapViewRectangle = getWorldmapViewRectangle();

    // =========================================================================
    // Revert if zoom is not allowed (too far, too close)
    if (!_changeZoomAndCheckIfAllowed(event, isZoomIn)) {
        return _revertZoom(); // Returns nothing, just exits
    }

    // Zoom is okay
    else {
        updateViewRectangle();
//        var diffInView = updateViewRectangle();
//        console.log(diffInView);
    }

    // =========================================================================
    // =========================================================================
    // Update view rectangle, make sure in bound, apply small fixes to center etc
    _afterZoomMakeSureWeReInbound(event, isZoomIn);

    // =========================================================================
    // Move every map location and change its size.
    _afterZoomUpdateMapLocations();

    // =========================================================================
    // Fire mouse move event because the map has moved
    mapMouseMove(event);

    // =========================================================================
    // Smoothly delay next zoom animation if needed
    _delayChangeZoom(event, isZoomIn);
}

function _afterZoomMakeSureWeReInbound(event, isZoomIn) {
    var topLeftCoords = getCurrentTopLeftPointMapCoordinates();
    var dX = topLeftCoords['mapX'] - _oldWorldmapViewRectangle['x'];
    var dY = topLeftCoords['mapY'] - _oldWorldmapViewRectangle['y'];

    // Enforce that the view rectangle is in bounds; moving the worldmap by [0,0] does that
    var counterModifier = 2;
    if (isZoomIn) {
        moveWorldmapBackgroundImage(_zoomStep / counterModifier, _zoomStep / counterModifier);
    } else {
        moveWorldmapBackgroundImage(_zoomStep / -counterModifier, _zoomStep / -counterModifier);
    }
}

function _afterZoomUpdateMapLocations() {

    // Recalculate margin-top for location label
    recalculateWorldmapLocationVariables();

    // Change location and size of every worldmap location
    var worldmapLocations = $(".worldmap-location");
    $.each(worldmapLocations, function (index, object) {
        var worldmapObject = $("#" + object['id']);
        var variableName = worldmapObject.attr('variableName');
        var variableIndex = worldmapObject.attr('variableIndex');
        var mapLocationObject = window[variableName][variableIndex];

        var canvasCoordinates = getCanvasCoordinatesFromMapCoordinates(
                mapLocationObject['location']['x'], mapLocationObject['location']['y']
                );

        // Change size, X and Y
        worldmapObject.css({
            'width': WORLDMAP_LOCATION_SIZE + 'px',
            'height': WORLDMAP_LOCATION_SIZE + 'px',
            'left': canvasCoordinates['canvasX'] - WORLDMAP_LOCATION_SIZE / 2,
            'top': canvasCoordinates['canvasY'] - WORLDMAP_LOCATION_SIZE / 2,
            'border-width': WORLDMAP_LOCATION_BORDER_WIDTH + 'px'
        });
    });

    // Change css for all worldmap location labels
    $(".worldmap-location label").css({
        'margin-top': WORLDMAP_LOCATION_LABEL_MARGIN_TOP + 'px',
        'margin-left': WORLDMAP_LOCATION_LABEL_MARGIN_LEFT + 'px',
    });
}

function _recalculateZoom() {
    _zoom = WORLDMAP_WIDTH / _currentWorldmapImageWidth;
}

function _changeZoomAndCheckIfAllowed(event, isZoomIn) {
    var quantumOfChange = _zoomStep; //  * _worldmapZoomCurrentSpeed
    if (isZoomIn) {
        _currentWorldmapImageWidth -= _zoomStep;
    } else {
        _currentWorldmapImageWidth += _zoomStep;
    }

    // Recalculate zoom
    _recalculateZoom();

    // === Revert zoom if too close/far =========================================

    var isZoomTooClose = _zoom < _MIN_ZOOM_VALUE; // Zoom is TOO BIG, background would be too pixel
    var isZoomTooFar = _currentWorldmapImageWidth < WORLDMAP_CANVAS_WIDTH;
    if (isZoomTooClose) {
        worldmapMessage("Maximum zoom reached!", "#f35");
        _zoomMessageWasShown = true;
        return false;
    } else if (isZoomTooFar) {
        worldmapMessage("Maximum zoom out reached!", "#2f3");
        _zoomMessageWasShown = true;
        return false;
    } else {
        return true;
    }
}

function _revertZoom() {
    _currentWorldmapImageWidth = _oldMapImageWidth;
    _zoom = _oldZoom;
    _worldmapViewRectangle = _oldWorldmapViewRectangle;
}

var WORLDMAP_WIDTH = 3500;
var WORLDMAP_HEIGHT = 3500;

// =========================================================================

window.initQueue.push(function () {
    setTimeout(function () {

        // =========================================================================
        // Create canvas and define view rectangle
        initializeWorldmap();
        initializeWorldmapView();

        // Initialize all canvas objects
        initializeWorldmapLocations();

        // Add all listeners
        initializeWorldmapEvents();
    }, 80);
});

// =========================================================================
// =========================================================================
// =========================================================================

var WORLDMAP_CANVAS_WIDTH = null;
var WORLDMAP_CANVAS_HEIGHT = null;

var WORLDMAP_CANVAS_MARGIN_LEFT = null;
var WORLDMAP_CANVAS_MARGIN_TOP = null;

var worldmap = null;

// === Initialize ======================================================================

function initializeWorldmap() {

    // =========================================================================
    // Define few layout related variables
    WORLDMAP_CANVAS_WIDTH = $(".worldmap").width();
    WORLDMAP_CANVAS_HEIGHT = $(".content-wrapper").height();

    WORLDMAP_CANVAS_MARGIN_LEFT = $(".sidebar").width();
    WORLDMAP_CANVAS_MARGIN_TOP = $(".main-header").height();
//    console.log("INIT WORLDMAP");
//    console.log("WORLDMAP_CANVAS_WIDTH = " + WORLDMAP_CANVAS_WIDTH);

    // =========================================================================
    var worldmap = $(".worldmap");
    getWorldmap().css('background-image', 'url("/img/map/map.jpg")');
}

// =========================================================================

function getWorldmap() {
    if (worldmap != null) {
        return worldmap;
    } else {
        worldmap = $(".worldmap");
        return worldmap;
    }
}
//# sourceMappingURL=game.min.js.map
